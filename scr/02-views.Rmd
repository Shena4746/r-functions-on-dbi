# Functions for Views

```{r knit-setting-for-views, eval = TRUE, include=FALSE}
knitr::opts_chunk$set(eval = TRUE, include = TRUE, echo = TRUE, warning = FALSE, collapse = TRUE)
```

```{r function-drop-all-views, include=FALSE}
drop_all_views <- function(con) {
    con %>%
        dbListViews() %>%
        purrr::map_int(~ dbDropView(con, .x, cascade = TRUE, if_exists = TRUE)) %>%
        sum()
}
```

```{r clear-view-table-for-view-section, include=FALSE}
# clear views and table, if any
con %>% drop_all_views()

con %>%
    dbListTables() %>%
    purrr::map_lgl(~ dbRemoveTable(con, .x)) %>%
    all()
```

table example

```{r prepare-mtcars-table}
if (con %>% dbExistsTable("mtcars") %>% isFALSE()) {
    con %>% dbWriteTable("mtcars", mtcars)
}

con %>%
    dbReadTable("mtcars") %>%
    head()
```

## Create a View

### Create a View from a SQL `SELECT` Statement

- Creates a view from the passed SQL query.
- Returns `TRUE` invisibly.
- `temporary = FALSE` and `or_replace = FALSE` arguments specify whether to enable `TEMPORARY` and `OR REPLACE` options, respectively. 

#### Definition

```{r def-create-view-dbi-show, ref.label='def-create-view-dbi', eval=FALSE}
```

Since `DBI::dbExecute` does not accept multiple statements, `dbCreateView` is not subject to SQL injection of that form.

#### Example

Given a set of `SELECT` queries and names that should be complied as views, you can create those views at once.

```{r create-many-views-at-once}
cyls <- c(4, 6, 8)
names <- purrr::map(cyls, ~ paste("view_cyl=", .x, sep = ""))
sqls <- purrr::map(cyls, ~ sqlInterpolate(
    con,
    "SELECT * FROM mtcars WHERE cyl = ?cyl",
    cyl = .x
))
# vectorised view creation
purrr::map2_lgl(sqls, names, ~ dbCreateView(con, .x, .y))
con %>% dbListViews()
```

```{r drop-cyl-views, include=FALSE}
con %>% drop_all_views()
```

### Create a View From a `tbl_lazy`

- Create a view from a `tbl_lazy` object that arises from typical dbplyr work.
- Returns `TRUE` invisibly.
- Accpepts the same arguments as `dbCreateView`.

#### Definition

```{r def-create-view-lazy-show, ref.label='def-create-view-lazy'}
```

#### Example

## List views

- Lists all view names, including tempoary ones.
- Returns a vector of strings represeting view names.
- The arguments `parmanent = TRUE` and `temporary = TRUE` specify whether to include non-temporal and tempoary views, respectively. An empty character is returned if both are set to `FALSE`.

### Definition
```{r def-list-views-show, ref.label='def-list-views'}
```

### Example

## Test existence of a view

- Test the existence of views.
- Returns a logical vector of the same length as the input.
- Accpepts the same arguments as `dbCreateView`.

### Definition

```{r def-exists-view-show, ref.label='def-exists-view'}
```

### Example

## Drop a view {#drop}

- Drops a view.
- Returns the total number of views dropped, invisibly.
- The arguments `if_exists = FALSE` and `cascade = FALSE` specify whether to enable the corresponding SQL options. If `cascade = FALSE`, the default, then `RESTRICT` option is set.

### Definition

```{r def-drop-view-show, ref.label='def-drop-view'}
```

### Example

View can be dropped in a vectorised way. If you are dropping temprary views only, then you can use the `DISCARD` statement \@ref(discard).

```{r drop-all-temporary-views-example}
# create views to demonstrate a vectorised removal
sql <- "SELECT * FROM mtcars LIMIT 10"
names <- purrr::map(1:4, ~ paste("view", .x, sep = ""))
tmps <- purrr::map(1:4, ~ .x <= 2)
purrr::map2_lgl(names, tmps, ~ dbCreateView(con, sql, .x, temporary = .y)) %>% invisible() # discard output

con %>% dbListViews()

# drop only temporary views
con %>%
    dbListViews(temporary = TRUE, parmanent = FALSE) %>%
    purrr::map_int(~ dbDropView(con, .x)) %>%
    sum() # total number of tables dropped

con %>% dbListViews() # non-temporary views are still alive

# drop them
con %>%
    dbListViews(temporary = FALSE, parmanent = TRUE) %>%
    purrr::map_int(~ dbDropView(con, .x)) %>%
    sum()

con %>% dbListViews()
```

Dependent views could be a source of an error during this vectorised removal. Set `if_exists = TRUE` whenever `cascade = TRUE` to omit this problem.

```{r drop-view-example-cascading, error=TRUE}
con %>% dbCreateView(
    sql = "SELECT * FROM mtcars LIMIT 10",
    name = "view_super"
)
con %>% dbCreateView(
    sql = "SELECT * FROM view_super LIMIT 10",
    name = "view_sub"
)

# set `if_exists = TRUE` to skip an cascade-dropped view
c("view_super", "view_sub") %>%
    purrr::map(~ dbDropView(con, .x, cascade = TRUE))
```

