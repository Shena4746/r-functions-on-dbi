
```{r knit-setting-for-def-views, eval = TRUE, include=FALSE}
# eval but not show codes in this files
knitr::opts_chunk$set(eval = TRUE, include = FALSE)
```

```{r def-create-view-dbi}
dbCreateView <- function(con, sql_view, name, or_replace = FALSE, temporary = FALSE) {
    if (sql_view %>% inherits(c("character", "SQL")) %>% isFALSE()) stop("provided sql string is not of class character or SQL.")
    sql <- "CREATE ?or ?tmp VIEW ?name AS ?q"
    stm <- DBI::sqlInterpolate(
        con,
        sql,
        or = dplyr::if_else(or_replace, "OR REPLACE", "") %>% DBI::SQL(),
        tmp = dplyr::if_else(temporary, "TEMPORARY", "") %>% DBI::SQL(),
        name = name %>% DBI::dbQuoteIdentifier(con, .),
        q = sql_view %>% DBI::SQL()
    )
    DBI::dbExecute(con, stm)
    invisible(TRUE) %>% return()
}
```

```{r def-create-view-lazy}
CreateView <- function(con, tbl, name, or_replace = FALSE, temporary = FALSE) {
    if (tbl %>% base::inherits("tbl_lazy") %>% isFALSE()) stop("provided tbl is not of class tbl_lazy")
    "CREATE ?or ?tmp VIEW ?name AS ?tbl_sql" %>%
        DBI::sqlInterpolate(
            con,
            .,
            or = dplyr::if_else(or_replace, "OR REPLACE", "") %>% DBI::SQL(),
            tmp = dplyr::if_else(temporary, "TEMPORARY", "") %>% DBI::SQL(),
            name = name %>% DBI::dbQuoteIdentifier(con, .),
            tbl_sql = dbplyr::sql_render(tbl) %>% SQL()
        ) %>%
        DBI::dbExecute(con, .)
    invisible(TRUE) %>% return()
}
```

```{r def-list-views}
dbListViews <- function(con, parmanent = TRUE, temporary = TRUE) {
    ret <- character()
    # this returns all views, temporary or not
    list_views <- function(x) {
        x %>%
            dbListTables() %>%
            setdiff(
                x %>%
                    DBI::dbGetQuery(
                        statement = "SELECT tablename FROM pg_tables WHERE schemaname = current_schema()"
                    ) %>% pull(1)
            )
    }
    # retruns only non-temporary views
    parm_views <- function(x) {
        x %>%
            dbGetQuery(
                statement = "SELECT viewname FROM pg_views WHERE schemaname = current_schema()"
            ) %>%
            pull(1)
    }
    # we can't use dplyr::case_when here, which requires the returned values be the same type and the same length.
    if (parmanent & temporary) {
        ret <- con %>% list_views()
    } else if (parmanent) {
        ret <- con %>% parm_views()
    } else if (temporary) {
        ret <- con %>%
            list_views() %>%
            setdiff(con %>% parm_views())
    }
    ret %>% return()
}
```

```{r def-exists-view}
dbExistsView <- function(con, name, parmanent = TRUE, temporary = TRUE) {
    name %in% dbListViews(con, parmanent, temporary)
}
```

```{r def-drop-view}
dbDropView <- function(con, name, if_exists = FALSE, cascade = FALSE) {
    if (!requireNamespace("dplyr", quietly = TRUE)) stop("dplyr library is required.")
    before <- con %>%
        dbListViews() %>%
        length()
    "DROP VIEW ?if_ex ?name ?cas_res" %>%
        DBI::sqlInterpolate(
            con,
            .,
            if_ex = dplyr::if_else(if_exists, "IF EXISTS", "") %>% DBI::SQL(),
            name = name %>% DBI::dbQuoteIdentifier(con, .),
            cas_res = dplyr::if_else(cascade, "CASCADE", "RESTRICT") %>% SQL()
        ) %>%
        DBI::dbExecute(con, .)
    before - (con %>% dbListViews() %>% length()) %>% invisible()
}
```