[["index.html", "User-defined functions that DBI + RPostgres users should have 1 About 1.1 Libraries 2 Connections 2.1 Issue a connection variable 2.2 Disconnect connections 3 Views 3.1 Create a view 3.2 List views 3.3 Test existence of views 3.4 Drop a view 4 Misc 4.1 Free Resources 4.2 Drop a Table 5 References: dbplyr, DBI, RPostgres", " User-defined functions that DBI + RPostgres users should have Shena 2022-07-10 1 About README on github. test 3.1 3.3 3.4 1.1 Libraries This document is based on the following libraries. R.version.string ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;RPostgres&quot;) ## [1] &#39;1.4.4.9000&#39; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.3&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; packageVersion(&quot;dbplyr&quot;) ## [1] &#39;2.2.1&#39; 2 Connections 2.1 Issue a connection variable Retruns a new DBIConnection object used to communicate with a database. It is recommended that you make sure you have disconnected old connections before using this. 2.1.1 Definition issue_con &lt;- function(service_name) { # assume you are using config package and Postgres crd &lt;- config::get(service_name) DBI::dbConnect( drv = RPostgres::Postgres(), host = crd$host, port = crd$port, dbname = crd$dbname, user = crd$user, password = crd$password ) } 2.1.2 Example Before setting a new connection variable, make sure that you are not trying to issue more connection variables than you need or overwrite exsisting one without disconnect it. So it is a good practice to disconnect before connecting, for instance, using release_cons defined below. release_cons() # Don&#39;t forget! ## character(0) con &lt;- issue_con(&quot;demo&quot;) con %&gt;% print() ## &lt;PqConnection&gt; demo@localhost:5432 2.2 Disconnect connections 2.2.1 Definition Disconnects all connection variables whose names are included in the passed vector of strings. Retruns a vector of characters listing connection variables that are disconnected by the function call. The arguments search_from = specifies a vector of strings that might contain connection variables to be disconnected. The default is set to a vector of names of all objects in the global namespace. The arguments except = NULL specifies a vector of strings that should be excluded from search_from argument. release_cons &lt;- function(search_from = ls(&quot;.GlobalEnv&quot;), except = NULL) { purrr::map_chr( .x = search_from %&gt;% base::setdiff(except), .f = function(x) { ret &lt;- &quot;&quot; if (x %&gt;% get() %&gt;% { inherits(., &quot;PqConnection&quot;) &amp; length(.) == 1 }) { ret &lt;- tryCatch( { x %&gt;% get() %&gt;% DBI::dbDisconnect() return(x) }, error = function(e) { msg &lt;- paste(&quot;Invalid PqConnection class object is provided:&quot;, x) message(msg) }, warning = function(e) { return(&quot;&quot;) } ) } return(ret) } ) %&gt;% .[. != &quot;&quot;] } 2.2.2 Example release_cons() %&gt;% invisible() con1 &lt;- issue_con(&quot;demo&quot;) con2 &lt;- issue_con(&quot;demo&quot;) cons &lt;- release_cons() cons %&gt;% print() ## [1] &quot;con1&quot; &quot;con2&quot; # check that they are actually disconnected purrr::map_lgl(cons, ~ dbDisconnect(.x %&gt;% get())) ## Warning in connection_release(conn@ptr): Already disconnected ## Warning in connection_release(conn@ptr): Already disconnected ## [1] TRUE TRUE # disconnect all connetions but &#39;con&#39; con &lt;- issue_con(&quot;demo&quot;) con1 &lt;- issue_con(&quot;demo&quot;) con2 &lt;- issue_con(&quot;demo&quot;) release_cons(except = &quot;con&quot;) ## [1] &quot;con1&quot; &quot;con2&quot; con %&gt;% print() # con is still valid ## &lt;PqConnection&gt; demo@localhost:5432 3 Views This section asssumes that mtcars table has been created in a remote table. if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbReadTable(&quot;mtcars&quot;) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 3.1 Create a view Creates a view from the passed SQL query. Returns TRUE invisibly. temporary = FALSE and or_replace = FALSE arguments specify whether to enable TEMPORARY and OR REPLACE options, respectively. 3.1.1 Definition dbCreateView &lt;- function(con, name, sql, or_replace = FALSE, temporary = FALSE) { if (sql %&gt;% inherits(c(&quot;character&quot;, &quot;SQL&quot;)) %&gt;% isFALSE()) stop(&quot;provided sql string is not of class character or SQL.&quot;) con %&gt;% DBI::sqlInterpolate( sql = &quot;CREATE ?or ?tmp VIEW ?name AS ?q&quot;, or = dplyr::if_else(or_replace, &quot;OR REPLACE&quot;, &quot;&quot;) %&gt;% DBI::SQL(), tmp = dplyr::if_else(temporary, &quot;TEMPORARY&quot;, &quot;&quot;) %&gt;% DBI::SQL(), name = DBI::dbQuoteIdentifier(., name), q = sql %&gt;% DBI::SQL() ) %&gt;% DBI::dbExecute(con, .) invisible(TRUE) %&gt;% return() } Since DBI::dbExecute does not accept multiple statements, dbCreateView is not subject to SQL injection of that form. 3.1.2 Example if (con %&gt;% dbExistsTable(&quot;cars&quot;) %&gt;% isFALSE()) con %&gt;% dbWriteTable(&quot;cars&quot;, cars) con %&gt;% dbCreateView( name = &quot;view_cars_20&quot;, sql = &quot;SELECT * FROM cars WHERE dist &lt; 20&quot; ) con %&gt;% dbReadTable(&quot;view_cars_20&quot;) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 8 16 ## 5 9 10 ## 6 10 18 ## 7 11 17 ## 8 12 14 # see the view properly follow the change in the referred table con %&gt;% dbAppendTable(&quot;cars&quot;, data.frame(speed = 7, dist = 19)) ## [1] 1 con %&gt;% dbReadTable(&quot;view_cars_20&quot;) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 8 16 ## 5 9 10 ## 6 10 18 ## 7 11 17 ## 8 12 14 ## 9 7 19 temporary views vanish when temporary resources are freed, which happenes, for instance, when dbDisconnect() is executed. sql &lt;- &quot;SELECT * FROM mtcars&quot; con %&gt;% dbCreateView(&quot;view_permanent&quot;, sql) con %&gt;% dbCreateView(&quot;view_temporary&quot;, sql, temporary = TRUE) con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; &quot;view_permanent&quot; &quot;view_temporary&quot; # reconnect con %&gt;% dbDisconnect() con &lt;- issue_con(&quot;demo&quot;) # temporary table has vanished con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; &quot;view_permanent&quot; Given a set of SELECT queries and names that should be complied as views, you can create those views at once. cyls &lt;- c(4, 6, 8) names &lt;- purrr::map(cyls, ~ paste(&quot;view_cyl=&quot;, .x, sep = &quot;&quot;)) sqls &lt;- purrr::map(cyls, ~ sqlInterpolate( con, &quot;SELECT * FROM mtcars WHERE cyl = ?cyl&quot;, cyl = .x )) # vectorised view creation purrr::map2_lgl(names, sqls, ~ dbCreateView(con, .x, .y)) ## [1] TRUE TRUE TRUE con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; &quot;view_cyl=4&quot; &quot;view_cyl=6&quot; &quot;view_cyl=8&quot; The combination of dbCreateView() and the dbplyr package allows you to create views without writing any SQL statements. This is often much quicker than working with SQL. if (con %&gt;% dbExistsTable(&quot;flights&quot;) %&gt;% isFALSE()) con %&gt;% dbWriteTable(&quot;flights&quot;, nycflights13::flights) # work on lazy table # get all rows with no missing values flights_no_NA &lt;- tbl(con, &quot;flights&quot;) %&gt;% filter(if_all(everything(), ~ !is.na(.))) flights_no_NA %&gt;% class() ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ## [5] &quot;tbl&quot; flights_no_NA %&gt;% summarise(n()) ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/demo] ## `n()` ## &lt;int64&gt; ## 1 327346 # number of NA on each columns flights_no_NA %&gt;% summarise( across( .cols = everything(), .fns = ~ if_else(is.na(.x), 1, 0) %&gt;% sum(), .names = &quot;{.col}_NA&quot; ) ) ## # Source: SQL [1 x 19] ## # Database: postgres [guest@localhost:5432/demo] ## year_NA month_NA day_NA dep_time_NA sched_dep_time_NA dep_delay_NA arr_time_NA ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 0 0 0 0 0 0 ## # … with 12 more variables: sched_arr_time_NA &lt;dbl&gt;, arr_delay_NA &lt;dbl&gt;, ## # carrier_NA &lt;dbl&gt;, flight_NA &lt;dbl&gt;, tailnum_NA &lt;dbl&gt;, origin_NA &lt;dbl&gt;, ## # dest_NA &lt;dbl&gt;, air_time_NA &lt;dbl&gt;, distance_NA &lt;dbl&gt;, hour_NA &lt;dbl&gt;, ## # minute_NA &lt;dbl&gt;, time_hour_NA &lt;dbl&gt; # transform it into a view con %&gt;% dbCreateView( name = &quot;flights_no_NA&quot;, sql = flights_no_NA %&gt;% dbplyr::sql_render() ) con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; &quot;flights&quot; &quot;flights_no_NA&quot; flights_view &lt;- con %&gt;% tbl(&quot;flights_no_NA&quot;) flights_no_NA %&gt;% summarise(n()) ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/demo] ## `n()` ## &lt;int64&gt; ## 1 327346 flights_view %&gt;% head() ## # Source: SQL [6 x 19] ## # Database: postgres [guest@localhost:5432/demo] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## # … with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.2 List views Lists all view names, including temporary ones. Returns a vector of strings representing view names. The arguments permanent = TRUE and temporary = TRUE specify whether to include non-temporal and temporary views, respectively. An empty character will be returned if both are set to FALSE. 3.2.1 Definition dbListViews &lt;- function(con, permanent = TRUE, temporary = TRUE) { ret &lt;- character() # this returns all views, temporary or not list_views &lt;- function(x) { x %&gt;% dbListTables() %&gt;% setdiff( x %&gt;% DBI::dbGetQuery( statement = &quot;SELECT tablename FROM pg_tables WHERE schemaname = current_schema()&quot; ) %&gt;% pull(1) ) } # retruns only non-temporary views parm_views &lt;- function(x) { x %&gt;% dbGetQuery( statement = &quot;SELECT viewname FROM pg_views WHERE schemaname = current_schema()&quot; ) %&gt;% pull(1) } # we can&#39;t use dplyr::case_when here, which requires the returned values be the same type and the same length. if (permanent &amp; temporary) { ret &lt;- con %&gt;% list_views() } else if (permanent) { ret &lt;- con %&gt;% parm_views() } else if (temporary) { ret &lt;- con %&gt;% list_views() %&gt;% setdiff(con %&gt;% parm_views()) } ret %&gt;% return() } 3.2.2 Example N &lt;- 3 sql &lt;- &quot;SELECT * FROM mtcars&quot; names &lt;- purrr::map(1:N, ~ paste(&quot;view_&quot;, .x, sep = &quot;&quot;)) names_tmp &lt;- purrr::map(1:N, ~ paste(&quot;view_temp_&quot;, .x, sep = &quot;&quot;)) # non-temporary views purrr::map_lgl(names, ~ dbCreateView(con, .x, sql)) ## [1] TRUE TRUE TRUE # temporary views purrr::map_lgl(names_tmp, ~ dbCreateView(con, .x, sql, temporary = TRUE)) ## [1] TRUE TRUE TRUE # show temoporary views con %&gt;% dbListViews(permanent = FALSE) ## [1] &quot;view_temp_1&quot; &quot;view_temp_2&quot; &quot;view_temp_3&quot; # show non-temoporary views con %&gt;% dbListViews(temporary = FALSE) ## [1] &quot;view_1&quot; &quot;view_2&quot; &quot;view_3&quot; 3.3 Test existence of views Test the existence of views. Returns a logical vector of the same length as the input. Accpepts the same arguments as dbCreateView. 3.3.1 Definition dbExistsViews &lt;- function(con, names, permanent = TRUE, temporary = TRUE) { names %in% dbListViews(con, permanent, temporary) } 3.3.2 Example sql &lt;- &quot;SELECT * FROM mtcars&quot; purrr::map2_lgl( .x = c(&quot;view&quot;, &quot;view_temp&quot;), .y = c(FALSE, TRUE), .f = ~ dbCreateView(con, .x, sql, temporary = .y) ) ## [1] TRUE TRUE viewnames &lt;- c(&quot;view&quot;, &quot;view_temp&quot;, &quot;view_absent&quot;) con %&gt;% dbExistsViews(viewnames) ## [1] TRUE TRUE FALSE con %&gt;% dbExistsViews(viewnames, permanent = FALSE) ## [1] FALSE TRUE FALSE con %&gt;% dbExistsViews(viewnames, temporary = FALSE) ## [1] TRUE FALSE FALSE 3.4 Drop a view Drops a view. Returns the total number of views dropped, invisibly. The arguments if_exists = FALSE and cascade = FALSE specify whether to enable the corresponding SQL options. If cascade = FALSE, the default, then RESTRICT option is set. 3.4.1 Definition dbDropView &lt;- function(con, name, if_exists = FALSE, cascade = FALSE) { before &lt;- con %&gt;% dbListViews() %&gt;% length() con %&gt;% DBI::sqlInterpolate( sql = &quot;DROP VIEW ?if_ex ?name ?cas_res&quot;, if_ex = dplyr::if_else(if_exists, &quot;IF EXISTS&quot;, &quot;&quot;) %&gt;% DBI::SQL(), name = DBI::dbQuoteIdentifier(con, name), cas_res = dplyr::if_else(cascade, &quot;CASCADE&quot;, &quot;RESTRICT&quot;) %&gt;% SQL() ) %&gt;% DBI::dbExecute(con, .) before - (con %&gt;% dbListViews() %&gt;% length()) %&gt;% invisible() } 3.4.2 Example View can be dropped in a vectorised way. If you are dropping temporary views only, then you can also use the DISCARD statement 4.1. # create views to demonstrate a vectorised removal sql &lt;- &quot;SELECT * FROM mtcars LIMIT 10&quot; names &lt;- purrr::map(1:4, ~ paste(&quot;view&quot;, .x, sep = &quot;&quot;)) tmps &lt;- purrr::map(1:4, ~ .x &lt;= 2) purrr::map2_lgl(names, tmps, ~ dbCreateView(con, .x, sql, temporary = .y)) %&gt;% invisible() # discard output con %&gt;% dbListViews() ## [1] &quot;view1&quot; &quot;view2&quot; &quot;view3&quot; &quot;view4&quot; # drop only temporary views con %&gt;% dbListViews(temporary = TRUE, permanent = FALSE) %&gt;% purrr::map_int(~ dbDropView(con, .x)) %&gt;% sum() # total number of tables dropped ## [1] 2 con %&gt;% dbListViews() # non-temporary views are still alive ## [1] &quot;view3&quot; &quot;view4&quot; # drop them con %&gt;% dbListViews(temporary = FALSE, permanent = TRUE) %&gt;% purrr::map_int(~ dbDropView(con, .x)) %&gt;% sum() ## [1] 2 con %&gt;% dbListViews() ## character(0) Dependent views could be a source of an error during this vectorised removal. Set if_exists = TRUE whenever cascade = TRUE to avoid this problem. con %&gt;% dbCreateView( name = &quot;view_super&quot;, sql = &quot;SELECT * FROM mtcars LIMIT 10&quot; ) con %&gt;% dbCreateView( name = &quot;view_sub&quot;, sql = &quot;SELECT * FROM view_super LIMIT 10&quot; ) # set `if_exists = TRUE` to skip an cascade-dropped view c(&quot;view_super&quot;, &quot;view_sub&quot;) %&gt;% purrr::map(~ dbDropView(con, .x, cascade = TRUE)) ## NOTICE: drop cascades to view view_sub ## Error: Failed to fetch row: ERROR: view &quot;view_sub&quot; does not exist 4 Misc 4.1 Free Resources Executes a DISCARD SQL statement. Returns TRUE invisibly even if it does nothing. The arguments all = FALSE, plans = FALSE and temporary = TRUE specify which of the corresponding SQL statement option should be applied. If multiple options are selected, only the most dominant one will be executed. If none is selected, nothing will be done. 4.1.1 Definition dbDiscard &lt;- function(con, all = FALSE, plans = FALSE, temporary = TRUE) { if (c(all, plans, temporary) %&gt;% any()) { resource &lt;- case_when( all ~ &quot;ALL&quot;, plans ~ &quot;PLANS&quot;, temporary ~ &quot;TEMPORARY&quot; ) &quot;DISCARD ?rsc&quot; %&gt;% DBI::sqlInterpolate( con, ., rsc = resource %&gt;% DBI::SQL() ) %&gt;% DBI::dbExecute(con, .) } invisible(TRUE) %&gt;% return() } 4.1.2 Example DISCARD TEMPORARY frees all tempoary resources at once, including tempoary views, instead of listing and dropping them, as we did in 3.4. # create temporary and non-temporary views sql &lt;- &quot;SELECT * FROM mtcars LIMIT 10&quot; purrr::map_lgl( .x = 1:4, ~ dbCreateView( con, name = paste(&quot;view&quot;, .x, sep = &quot;&quot;), sql = sql, temporary = isTRUE(.x &lt;= 2) ) ) ## [1] TRUE TRUE TRUE TRUE con %&gt;% dbListViews() ## [1] &quot;view2&quot; &quot;view3&quot; &quot;view4&quot; &quot;view1&quot; con %&gt;% dbDiscard(temporary = TRUE) # delete all temporary objects con %&gt;% dbListViews() # non-temporary views are still alive ## [1] &quot;view3&quot; &quot;view4&quot; 4.2 Drop a Table 4.2.1 Definition Drop a table, with IF EXISTS and CASCADE option. Returns the total number of views dropped, invisibly. See ?? for the usage of optional arguments. dbDropTables &lt;- function(conn, name, if_exists = FALSE, cascade = FALSE) { before &lt;- con %&gt;% dbListTables() %&gt;% length() con %&gt;% DBI::sqlInterpolate( sql = &quot;DROP TABLE ?if_ex ?name ?cas_res&quot;, if_ex = dplyr::if_else(if_exists, &quot;IF EXISTS&quot;, &quot;&quot;) %&gt;% DBI::SQL(), name = DBI::dbQuoteIdentifier(con, name), cas_res = dplyr::if_else(cascade, &quot;CASCADE&quot;, &quot;RESTRICT&quot;) %&gt;% SQL() ) %&gt;% DBI::dbExecute(con, .) before - (con %&gt;% dbListTables() %&gt;% length()) %&gt;% invisible() } 4.2.2 Example sql &lt;- &quot;SELECT * FROM mtcars&quot; purrr::map_lgl( .x = 1:3, .f = ~ dbCreateView(con, name = paste0(&quot;view&quot;, .x), sql) ) ## [1] TRUE TRUE TRUE con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; &quot;view2&quot; &quot;view3&quot; &quot;view1&quot; # specifying a view causes an error con %&gt;% dbDropTables(&quot;view2&quot;, if_exists = TRUE) ## Error: Failed to fetch row: ERROR: &quot;view2&quot; is not a table ## HINT: Use DROP VIEW to remove a view. con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; &quot;view2&quot; &quot;view3&quot; &quot;view1&quot; # specifying a referred table deletes all dependent views con %&gt;% dbDropTables(&quot;mtcars&quot;, cascade = TRUE) ## NOTICE: drop cascades to 3 other objects ## DETAIL: drop cascades to view view1 ## drop cascades to view view2 ## drop cascades to view view3 ## [1] 4 con %&gt;% dbListTables() ## character(0) 5 References: dbplyr, DBI, RPostgres Introduction 巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として Introduction to dbplyr R: Working with Databases Introduction to DBI DBI RSQLite &amp; DBIの使い方 DBI specification DBI: R Database Interface .pdf Code Examples for DBI and RPostgres RPostgres RPostgres - Reference "]]
