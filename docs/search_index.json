[["index.html", "Supplementary functions for DBI + RPostgres 1 Libraries 2 Connection 3 Functions for Views 3.1 Create a View 3.2 List views 3.3 Test existence of a view 3.4 Drop a view 4 Misc 4.1 Free resources", " Supplementary functions for DBI + RPostgres Shena 2022-07-08 1 Libraries library(&quot;RPostgres&quot;) library(&quot;DBI&quot;) library(&quot;dplyr&quot;) library(&quot;dbplyr&quot;) This document is based on the following conditions. R.version.string ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;RPostgres&quot;) ## [1] &#39;1.4.4.9000&#39; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.3&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; packageVersion(&quot;dbplyr&quot;) ## [1] &#39;2.2.1&#39; 2 Connection issue_con &lt;- function(service_name) { dw &lt;- config::get(service_name) con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = dw$host, port = dw$port, dbname = dw$dbname, user = dw$user, password = dw$password ) } con &lt;- issue_con(&quot;demo&quot;) 3 Functions for Views table example if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbReadTable(&quot;mtcars&quot;) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 3.1 Create a View 3.1.1 Create a View from a SQL SELECT Statement Creates a view from the passed SQL query. Returns TRUE invisibly. temporary = FALSE and or_replace = FALSE arguments specify whether to enable TEMPORARY and OR REPLACE options, respectively. 3.1.1.1 Definition dbCreateView &lt;- function(con, sql_view, name, or_replace = FALSE, temporary = FALSE) { if (sql_view %&gt;% inherits(c(&quot;character&quot;, &quot;SQL&quot;)) %&gt;% isFALSE()) stop(&quot;provided sql string is not of class character or SQL.&quot;) sql &lt;- &quot;CREATE ?or ?tmp VIEW ?name AS ?q&quot; stm &lt;- DBI::sqlInterpolate( con, sql, or = dplyr::if_else(or_replace, &quot;OR REPLACE&quot;, &quot;&quot;) %&gt;% DBI::SQL(), tmp = dplyr::if_else(temporary, &quot;TEMPORARY&quot;, &quot;&quot;) %&gt;% DBI::SQL(), name = name %&gt;% DBI::dbQuoteIdentifier(con, .), q = sql_view %&gt;% DBI::SQL() ) DBI::dbExecute(con, stm) invisible(TRUE) %&gt;% return() } Since DBI::dbExecute does not accept multiple statements, dbCreateView is not subject to SQL injection of that form. 3.1.1.2 Example Given a set of SELECT queries and names that should be complied as views, you can create those views at once. cyls &lt;- c(4, 6, 8) names &lt;- purrr::map(cyls, ~ paste(&quot;view_cyl=&quot;, .x, sep = &quot;&quot;)) sqls &lt;- purrr::map(cyls, ~ sqlInterpolate( con, &quot;SELECT * FROM mtcars WHERE cyl = ?cyl&quot;, cyl = .x )) # vectorised view creation purrr::map2_lgl(sqls, names, ~ dbCreateView(con, .x, .y)) ## [1] TRUE TRUE TRUE con %&gt;% dbListViews() ## [1] &quot;view_cyl=4&quot; &quot;view_cyl=6&quot; &quot;view_cyl=8&quot; 3.1.2 Create a View From a tbl_lazy Create a view from a tbl_lazy object that arises from typical dbplyr work. Returns TRUE invisibly. Accpepts the same arguments as dbCreateView. 3.1.2.1 Definition CreateView &lt;- function(con, tbl, name, or_replace = FALSE, temporary = FALSE) { if (tbl %&gt;% base::inherits(&quot;tbl_lazy&quot;) %&gt;% isFALSE()) stop(&quot;provided tbl is not of class tbl_lazy&quot;) &quot;CREATE ?or ?tmp VIEW ?name AS ?tbl_sql&quot; %&gt;% DBI::sqlInterpolate( con, ., or = dplyr::if_else(or_replace, &quot;OR REPLACE&quot;, &quot;&quot;) %&gt;% DBI::SQL(), tmp = dplyr::if_else(temporary, &quot;TEMPORARY&quot;, &quot;&quot;) %&gt;% DBI::SQL(), name = name %&gt;% DBI::dbQuoteIdentifier(con, .), tbl_sql = dbplyr::sql_render(tbl) %&gt;% SQL() ) %&gt;% DBI::dbExecute(con, .) invisible(TRUE) %&gt;% return() } 3.1.2.2 Example 3.2 List views Lists all view names, including tempoary ones. Returns a vector of strings represeting view names. The arguments parmanent = TRUE and temporary = TRUE specify whether to include non-temporal and tempoary views, respectively. An empty character is returned if both are set to FALSE. 3.2.1 Definition dbListViews &lt;- function(con, parmanent = TRUE, temporary = TRUE) { ret &lt;- character() # this returns all views, temporary or not list_views &lt;- function(x) { x %&gt;% dbListTables() %&gt;% setdiff( x %&gt;% DBI::dbGetQuery( statement = &quot;SELECT tablename FROM pg_tables WHERE schemaname = current_schema()&quot; ) %&gt;% pull(1) ) } # retruns only non-temporary views parm_views &lt;- function(x) { x %&gt;% dbGetQuery( statement = &quot;SELECT viewname FROM pg_views WHERE schemaname = current_schema()&quot; ) %&gt;% pull(1) } # we can&#39;t use dplyr::case_when here, which requires the returned values be the same type and the same length. if (parmanent &amp; temporary) { ret &lt;- con %&gt;% list_views() } else if (parmanent) { ret &lt;- con %&gt;% parm_views() } else if (temporary) { ret &lt;- con %&gt;% list_views() %&gt;% setdiff(con %&gt;% parm_views()) } ret %&gt;% return() } 3.2.2 Example 3.3 Test existence of a view Test the existence of views. Returns a logical vector of the same length as the input. Accpepts the same arguments as dbCreateView. 3.3.1 Definition dbExistsView &lt;- function(con, name, parmanent = TRUE, temporary = TRUE) { name %in% dbListViews(con, parmanent, temporary) } 3.3.2 Example 3.4 Drop a view Drops a view. Returns the total number of views dropped, invisibly. The arguments if_exists = FALSE and cascade = FALSE specify whether to enable the corresponding SQL options. If cascade = FALSE, the default, then RESTRICT option is set. 3.4.1 Definition dbDropView &lt;- function(con, name, if_exists = FALSE, cascade = FALSE) { if (!requireNamespace(&quot;dplyr&quot;, quietly = TRUE)) stop(&quot;dplyr library is required.&quot;) before &lt;- con %&gt;% dbListViews() %&gt;% length() &quot;DROP VIEW ?if_ex ?name ?cas_res&quot; %&gt;% DBI::sqlInterpolate( con, ., if_ex = dplyr::if_else(if_exists, &quot;IF EXISTS&quot;, &quot;&quot;) %&gt;% DBI::SQL(), name = name %&gt;% DBI::dbQuoteIdentifier(con, .), cas_res = dplyr::if_else(cascade, &quot;CASCADE&quot;, &quot;RESTRICT&quot;) %&gt;% SQL() ) %&gt;% DBI::dbExecute(con, .) before - (con %&gt;% dbListViews() %&gt;% length()) %&gt;% invisible() } 3.4.2 Example View can be dropped in a vectorised way. If you are dropping temprary views only, then you can use the DISCARD statement 4.1. # create views to demonstrate a vectorised removal sql &lt;- &quot;SELECT * FROM mtcars LIMIT 10&quot; names &lt;- purrr::map(1:4, ~ paste(&quot;view&quot;, .x, sep = &quot;&quot;)) tmps &lt;- purrr::map(1:4, ~ .x &lt;= 2) purrr::map2_lgl(names, tmps, ~ dbCreateView(con, sql, .x, temporary = .y)) %&gt;% invisible() # discard output con %&gt;% dbListViews() ## [1] &quot;view3&quot; &quot;view1&quot; &quot;view2&quot; &quot;view4&quot; # drop only temporary views con %&gt;% dbListViews(temporary = TRUE, parmanent = FALSE) %&gt;% purrr::map_int(~ dbDropView(con, .x)) %&gt;% sum() # total number of tables dropped ## [1] 2 con %&gt;% dbListViews() # non-temporary views are still alive ## [1] &quot;view3&quot; &quot;view4&quot; # drop them con %&gt;% dbListViews(temporary = FALSE, parmanent = TRUE) %&gt;% purrr::map_int(~ dbDropView(con, .x)) %&gt;% sum() ## [1] 2 con %&gt;% dbListViews() ## character(0) Dependent views could be a source of an error during this vectorised removal. Set if_exists = TRUE whenever cascade = TRUE to omit this problem. con %&gt;% dbCreateView( sql = &quot;SELECT * FROM mtcars LIMIT 10&quot;, name = &quot;view_super&quot; ) con %&gt;% dbCreateView( sql = &quot;SELECT * FROM view_super LIMIT 10&quot;, name = &quot;view_sub&quot; ) # set `if_exists = TRUE` to skip an cascade-dropped view c(&quot;view_super&quot;, &quot;view_sub&quot;) %&gt;% purrr::map(~ dbDropView(con, .x, cascade = TRUE)) ## NOTICE: drop cascades to view view_sub ## Error: Failed to fetch row: ERROR: view &quot;view_sub&quot; does not exist 4 Misc 4.1 Free resources Executes a DISCARD SQL statement. Returns TRUE invisibly even if it does nothing. The arguments all = FALSE, plans = TRUE and temporary = TRUE specify which of the corresponding SQL statement option should be applied. If multiple options are selected, only the most dominant one will be executed. If none is selected, nothing will be done. 4.1.1 Definition dbDiscard &lt;- function(con, all = FALSE, plans = FALSE, temporary = TRUE) { if (c(all, plans, temporary) %&gt;% any()) { resource &lt;- case_when( all ~ &quot;ALL&quot;, plans ~ &quot;PLANS&quot;, temporary ~ &quot;TEMPORARY&quot; ) &quot;DISCARD ?rsc&quot; %&gt;% DBI::sqlInterpolate( con, ., rsc = resource %&gt;% DBI::SQL() ) %&gt;% DBI::dbExecute(con, .) } invisible(TRUE) %&gt;% return() } 4.1.2 Example DISCARD TEMPORARY removes tempoary views at once, intead of listing and dropping them, as we did in 3.4. # prepare temporary and non-temporary views sql &lt;- &quot;SELECT * FROM mtcars LIMIT 10&quot; for (i in 1:4) { dbCreateView(con, sql, paste(&quot;view&quot;, i, sep = &quot;&quot;), temporary = isTRUE(i &lt;= 2)) } con %&gt;% dbListViews() ## [1] &quot;view4&quot; &quot;view1&quot; &quot;view2&quot; &quot;view3&quot; con %&gt;% dbDiscard(temporary = TRUE) # delte all temporary objects con %&gt;% dbListViews() # non-temporary views are stil alive ## [1] &quot;view4&quot; &quot;view3&quot; "]]
