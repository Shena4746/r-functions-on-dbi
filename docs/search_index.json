[["index.html", "Code Examples for DBI and RPostgres 1 About DBI and RPostgres 1.1 Overview 1.2 List of Functions 1.3 Basic Usage 2 Functions in DBI and RPostgres 2.1 Connecting and Disconnecting 2.2 Manipulating Tables", " Code Examples for DBI and RPostgres Shena 2022-07-04 1 About DBI and RPostgres library(&quot;RPostgres&quot;) library(&quot;DBI&quot;) library(&quot;dbplyr&quot;) library(&quot;dplyr&quot;) This document is based on the following conditions. R.version.string ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;RPostgres&quot;) ## [1] &#39;1.4.4.9000&#39; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.3&#39; packageVersion(&quot;dbplyr&quot;) ## [1] &#39;2.2.1&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; packageVersion(&quot;purrr&quot;) ## [1] &#39;0.3.4&#39; 1.1 Overview 1.2 List of Functions 1.2.1 Functions in DBI # functions in dbi package dbi &lt;- ls(&quot;package:DBI&quot;) dbi %&gt;% length() # how many ? ## [1] 67 dbi %&gt;% print() ## [1] &quot;ANSI&quot; &quot;dbAppendTable&quot; &quot;dbBegin&quot; ## [4] &quot;dbBind&quot; &quot;dbBreak&quot; &quot;dbCallProc&quot; ## [7] &quot;dbCanConnect&quot; &quot;dbClearResult&quot; &quot;dbColumnInfo&quot; ## [10] &quot;dbCommit&quot; &quot;dbConnect&quot; &quot;dbCreateTable&quot; ## [13] &quot;dbDataType&quot; &quot;dbDisconnect&quot; &quot;dbDriver&quot; ## [16] &quot;dbExecute&quot; &quot;dbExistsTable&quot; &quot;dbFetch&quot; ## [19] &quot;dbGetConnectArgs&quot; &quot;dbGetDBIVersion&quot; &quot;dbGetException&quot; ## [22] &quot;dbGetInfo&quot; &quot;dbGetQuery&quot; &quot;dbGetRowCount&quot; ## [25] &quot;dbGetRowsAffected&quot; &quot;dbGetStatement&quot; &quot;dbHasCompleted&quot; ## [28] &quot;dbIsReadOnly&quot; &quot;dbIsValid&quot; &quot;dbListConnections&quot; ## [31] &quot;dbListFields&quot; &quot;dbListObjects&quot; &quot;dbListResults&quot; ## [34] &quot;dbListTables&quot; &quot;dbQuoteIdentifier&quot; &quot;dbQuoteLiteral&quot; ## [37] &quot;dbQuoteString&quot; &quot;dbReadTable&quot; &quot;dbRemoveTable&quot; ## [40] &quot;dbRollback&quot; &quot;dbSendQuery&quot; &quot;dbSendStatement&quot; ## [43] &quot;dbSetDataMappings&quot; &quot;dbUnloadDriver&quot; &quot;dbUnquoteIdentifier&quot; ## [46] &quot;dbWithTransaction&quot; &quot;dbWriteTable&quot; &quot;fetch&quot; ## [49] &quot;Id&quot; &quot;isSQLKeyword&quot; &quot;isSQLKeyword.default&quot; ## [52] &quot;make.db.names&quot; &quot;make.db.names.default&quot; &quot;show&quot; ## [55] &quot;SQL&quot; &quot;sqlAppendTable&quot; &quot;sqlAppendTableTemplate&quot; ## [58] &quot;sqlColumnToRownames&quot; &quot;sqlCommentSpec&quot; &quot;sqlCreateTable&quot; ## [61] &quot;sqlData&quot; &quot;sqlInterpolate&quot; &quot;SQLKeywords&quot; ## [64] &quot;sqlParseVariables&quot; &quot;sqlParseVariablesImpl&quot; &quot;sqlQuoteSpec&quot; ## [67] &quot;sqlRownamesToColumn&quot; 1.2.2 Functions in RPostgres # functions in RPostgres package rpos &lt;- ls(&quot;package:RPostgres&quot;) rpos %&gt;% length() # how many ? ## [1] 48 rpos %&gt;% print() ## [1] &quot;dbAppendTable&quot; &quot;dbBegin&quot; &quot;dbBind&quot; ## [4] &quot;dbCanConnect&quot; &quot;dbClearResult&quot; &quot;dbColumnInfo&quot; ## [7] &quot;dbCommit&quot; &quot;dbConnect&quot; &quot;dbCreateTable&quot; ## [10] &quot;dbDataType&quot; &quot;dbDisconnect&quot; &quot;dbDriver&quot; ## [13] &quot;dbExecute&quot; &quot;dbExistsTable&quot; &quot;dbFetch&quot; ## [16] &quot;dbGetInfo&quot; &quot;dbGetQuery&quot; &quot;dbGetRowCount&quot; ## [19] &quot;dbGetRowsAffected&quot; &quot;dbGetStatement&quot; &quot;dbHasCompleted&quot; ## [22] &quot;dbIsReadOnly&quot; &quot;dbIsValid&quot; &quot;dbListFields&quot; ## [25] &quot;dbListObjects&quot; &quot;dbListResults&quot; &quot;dbListTables&quot; ## [28] &quot;dbQuoteIdentifier&quot; &quot;dbQuoteLiteral&quot; &quot;dbQuoteString&quot; ## [31] &quot;dbReadTable&quot; &quot;dbRemoveTable&quot; &quot;dbRollback&quot; ## [34] &quot;dbSendQuery&quot; &quot;dbSendStatement&quot; &quot;dbUnloadDriver&quot; ## [37] &quot;dbUnquoteIdentifier&quot; &quot;dbWithTransaction&quot; &quot;dbWriteTable&quot; ## [40] &quot;Id&quot; &quot;Postgres&quot; &quot;postgresDefault&quot; ## [43] &quot;postgresHasDefault&quot; &quot;postgresIsTransacting&quot; &quot;postgresWaitForNotify&quot; ## [46] &quot;Redshift&quot; &quot;show&quot; &quot;sqlData&quot; 1.2.3 Functions with duplicated names You might have noticed that there are quite a few functions with the same name in these packages. They provides the same functionlaity, possibly with the different implementation and efficiecy. # common functions in DBI and RPostgres common &lt;- base::intersect(dbi, rpos) common %&gt;% length() # how many ? ## [1] 42 common %&gt;% print() ## [1] &quot;dbAppendTable&quot; &quot;dbBegin&quot; &quot;dbBind&quot; ## [4] &quot;dbCanConnect&quot; &quot;dbClearResult&quot; &quot;dbColumnInfo&quot; ## [7] &quot;dbCommit&quot; &quot;dbConnect&quot; &quot;dbCreateTable&quot; ## [10] &quot;dbDataType&quot; &quot;dbDisconnect&quot; &quot;dbDriver&quot; ## [13] &quot;dbExecute&quot; &quot;dbExistsTable&quot; &quot;dbFetch&quot; ## [16] &quot;dbGetInfo&quot; &quot;dbGetQuery&quot; &quot;dbGetRowCount&quot; ## [19] &quot;dbGetRowsAffected&quot; &quot;dbGetStatement&quot; &quot;dbHasCompleted&quot; ## [22] &quot;dbIsReadOnly&quot; &quot;dbIsValid&quot; &quot;dbListFields&quot; ## [25] &quot;dbListObjects&quot; &quot;dbListResults&quot; &quot;dbListTables&quot; ## [28] &quot;dbQuoteIdentifier&quot; &quot;dbQuoteLiteral&quot; &quot;dbQuoteString&quot; ## [31] &quot;dbReadTable&quot; &quot;dbRemoveTable&quot; &quot;dbRollback&quot; ## [34] &quot;dbSendQuery&quot; &quot;dbSendStatement&quot; &quot;dbUnloadDriver&quot; ## [37] &quot;dbUnquoteIdentifier&quot; &quot;dbWithTransaction&quot; &quot;dbWriteTable&quot; ## [40] &quot;Id&quot; &quot;show&quot; &quot;sqlData&quot; We don’t go into the (potentially deep) difference of these twin functions. This document prefers to using DBI:: methods as introduced in GitHub repository of RPostgres package, unless there is a significant difference between them. 1.2.4 Funcions only in DBI # functions only in DBI only_in_dbi &lt;- base::setdiff(dbi, rpos) only_in_dbi %&gt;% length() # how many ? ## [1] 25 only_in_dbi %&gt;% print() ## [1] &quot;ANSI&quot; &quot;dbBreak&quot; &quot;dbCallProc&quot; ## [4] &quot;dbGetConnectArgs&quot; &quot;dbGetDBIVersion&quot; &quot;dbGetException&quot; ## [7] &quot;dbListConnections&quot; &quot;dbSetDataMappings&quot; &quot;fetch&quot; ## [10] &quot;isSQLKeyword&quot; &quot;isSQLKeyword.default&quot; &quot;make.db.names&quot; ## [13] &quot;make.db.names.default&quot; &quot;SQL&quot; &quot;sqlAppendTable&quot; ## [16] &quot;sqlAppendTableTemplate&quot; &quot;sqlColumnToRownames&quot; &quot;sqlCommentSpec&quot; ## [19] &quot;sqlCreateTable&quot; &quot;sqlInterpolate&quot; &quot;SQLKeywords&quot; ## [22] &quot;sqlParseVariables&quot; &quot;sqlParseVariablesImpl&quot; &quot;sqlQuoteSpec&quot; ## [25] &quot;sqlRownamesToColumn&quot; 1.2.5 Funcions only in RPostgres # functions only in RPostgres only_in_rpos &lt;- base::setdiff(rpos, dbi) only_in_rpos %&gt;% length() # how many ? ## [1] 6 only_in_rpos %&gt;% print() ## [1] &quot;Postgres&quot; &quot;postgresDefault&quot; &quot;postgresHasDefault&quot; ## [4] &quot;postgresIsTransacting&quot; &quot;postgresWaitForNotify&quot; &quot;Redshift&quot; 1.3 Basic Usage Before we look at indivisual functions, let us describe a typical work flow with these packages. You may sefaly skip this section as it is independent of what follows. This section assumes that you have access to a postgres database. If necessary, run the following command to create a new database named ‘demo’. sudo service postgresql start createdb -p 5432 --owner=your-owner-name --host=localhost --username=your-username demo The following code defines the con variable which keeps the establised connection to your database. con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) You should not write this way outside this demo. See @ref(dbConnect.) Let us observe the list of tables in the connected database. # demo database is empty con %&gt;% DBI::dbListTables() ## character(0) dbWriteTable() Creates a remote table from local data. The last two arguments are optional. # create table by supplying local dataframe con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE, temoprary = TRUE) con %&gt;% dbWriteTable(&quot;iris&quot;, iris, overwrite = TRUE, temoprary = TRUE) # check that tables are properly created DBI::dbListTables(con) ## [1] &quot;mtcars&quot; &quot;iris&quot; You can also ask the existance of the specific table in the database associated with con variable. # boolean question about the existance of indivisual table con %&gt;% DBI::dbExistsTable(&quot;mtcars&quot;) ## [1] TRUE dbListFields() gets you the list of fields of an indivisual table. # now we have con %&gt;% DBI::dbListFields(&quot;mtcars&quot;) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; dbReadTable() allows you to take a quick peep at a table. con %&gt;% DBI::dbReadTable(&quot;mtcars&quot;) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 You can use dbSendQuery() to execute a query written in a string. Note that we don’t need a ; at the end of the query. Since this method does nothing but sending query, you should capture the returned value to perform an appropriate post-processing. # send query and get response variable rs &lt;- con %&gt;% DBI::dbSendQuery(&quot; SELECT * FROM mtcars WHERE hp &lt;= 100 &quot;) dbFetch() shows you the result of the query. rs %&gt;% DBI::dbFetch() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 6 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 7 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 8 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 9 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Don’t forget to do dbClearResult(). DBI package keeps many kinds of resources associated with the result of the query unless manually cleared. dbClearResult() is responsible for that freeing role. DBI reference says that This step is mandatory for all objects obtained by calling dbSendQuery() or dbSendStatement(). rs %&gt;% dbClearResult() We can write a parameterised query in the following way. $1 and $2 corresponds to the first and second argument in the list(100, 120), respectively. rs &lt;- con %&gt;% dbSendQuery(&quot; SELECT * FROM mtcars WHERE hp BETWEEN $1 AND $2 &quot;) rs %&gt;% dbBind(list(100, 120)) rs %&gt;% dbFetch() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 4 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 5 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 6 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 rs %&gt;% dbClearResult() You can delete a table by dbRemoveTable(). # remove indivisual table by supplying name string con %&gt;% DBI::dbRemoveTable(&quot;mtcars&quot;) It is often useful to have a function that deletes multiple tables at once based on a pre-defined rule. The following code is one of the most simplest, deleting all tables. # create mtcars table again to demonstate sumultaneous-removal con %&gt;% DBI::dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE, temoprary = TRUE) DBI::dbListTables(con) ## [1] &quot;iris&quot; &quot;mtcars&quot; # remove multiple tables at once con %&gt;% DBI::dbListTables() %&gt;% purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %&gt;% all() ## [1] TRUE DBI::dbListTables(con) ## character(0) dbDisconnect() terminates the supplied con variable, and closes the connection. con %&gt;% DBI::dbDisconnect() 2 Functions in DBI and RPostgres For convenience, we define a function that issues a connection variable. # depends on config package to handling credentials issue_con &lt;- function(service_name) { dw &lt;- config::get(service_name) DBI::dbConnect( drv = RPostgres::Postgres(), host = dw$host, port = dw$port, dbname = dw$dbname, user = dw$user, password = dw$password ) } remove_all_table &lt;- function(con) { con %&gt;% DBI::dbListTables() %&gt;% purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %&gt;% all() } 2.1 Connecting and Disconnecting 2.1.1 dbCanConnect() Checks if a connection to a DBMS can be established Retruns logical. If FALSE, it comes with a reason for failure. DBI::dbCanConnect(drv = RPostgres::Postgres()) ## [1] TRUE RPostgres::dbCanConnect(drv = RPostgres::Postgres()) ## [1] TRUE 2.1.2 dbConnect() Creates a connection to a DBMS. Retruns S4 object (that inherits from DBIConnection virtual class), which holds the established connection information used to communicate with database. Many connection variable can exist at the same time without affecting each other. The following example shows a typical argument list for connecting to Postgres. con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) Be aware that this is a terrible way of connecting to a non-demo database because your credentials are completely revealed in a plain text. See Securing Credentials for some better ways. In this document, we issue connection variables by calling issue_con defined in 2. con &lt;- issue_con(&quot;demo&quot;) # connection variable is printable con %&gt;% print() ## &lt;PqConnection&gt; demo@localhost:5432 2.1.3 dbDisconnect() Closes the associated connection, discards all associated pending work, and frees resources. Retruns TRUE invisibly. Issues warning on an already disconnected connnectinon variable or invalid one. NOT clears a supplied connection object. # disconnect con varibale. returns nothing. con %&gt;% dbDisconnect() # get warned since con is already disconnected con %&gt;% dbDisconnect() ## Warning in connection_release(conn@ptr): Already disconnected Disconnected object continues to exist as a non-null object. con %&gt;% is.null() ## [1] FALSE But it is no longer printable. con %&gt;% print() ## Error: Invalid connection Disconnection has a local effect. That is, disconnecting one connection has no impact on other connections. con &lt;- issue_con(&quot;demo&quot;) con1 &lt;- issue_con(&quot;demo&quot;) con1 %&gt;% dbDisconnect() # con is still valid con %&gt;% print() ## &lt;PqConnection&gt; demo@localhost:5432 2.1.4 dbGetInfo() Retrieves information on database objects, i.e., DBIDriver (e.g., RPostgres::Postgres), DBIConnection (e.g., con) or DBIResult (e.g., dbSendQuery()). Returns a named list whose components depend on the input class. dbGetInfo(RPostgres::Postgres()) ## $driver.version ## [1] &#39;1.4.4.9000&#39; ## ## $client.version ## [1] &#39;12.11&#39; con %&gt;% dbGetInfo() ## $dbname ## [1] &quot;demo&quot; ## ## $host ## [1] &quot;localhost&quot; ## ## $port ## [1] &quot;5432&quot; ## ## $username ## [1] &quot;guest&quot; ## ## $protocol.version ## [1] 3 ## ## $server.version ## [1] 120011 ## ## $db.version ## [1] 120011 ## ## $pid ## [1] 18286 2.1.5 dbIsReadOnly() Tests whether a database object is read only. Returns logical. con %&gt;% dbIsReadOnly() ## [1] FALSE dbIsReadOnly(RPostgres::Postgres()) ## [1] FALSE 2.2 Manipulating Tables 2.2.1 dbWriteTable() Writes, overwrites or appends a data frame to a database table Various optional argumets (must be provided as named arguments) available such as temoprary = FALSE: a logical specifying whether a created table should be temoprary in the sense that it vanishes after disconection. NOT available with postgres. overwrite = FALSE: a logical specifying whether to overwrite an existing table. append = FALSE: a logical specifying whether to append to an existing table. The following example demonstrates that DBI::dbWriteTable() does not accept temoprary = option. Note that no error or warnig is raised. The same is true for Postgres::dbWriteTable(). # temprary = TRUE is available? con %&gt;% RPostgres::dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE, temoprary = TRUE) # show list of tables currently available con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; # refresh connnection con %&gt;% dbDisconnect() con &lt;- issue_con(&quot;demo&quot;) # is the table still alive? -&gt; yes con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; 2.2.2 dbListTables() Returns a character vector that enumerates all tables and views in the database. In Postgres, this includes views and temprary objects created by dplyr::copy_to(), but not those by dbplyr::copy_inline(). con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; 2.2.3 dbListObjects() Returns a data frame with columns table and is_prefix in that order. Works also for temprary tables created by dplyr::copy_to() in Postgres. con %&gt;% dbListObjects() ## table is_prefix ## 1 &lt;Id&gt; table = mtcars FALSE ## 2 &lt;Id&gt; schema = public TRUE ## 3 &lt;Id&gt; schema = information_schema TRUE ## 4 &lt;Id&gt; schema = pg_catalog TRUE 2.2.4 dbListFields() Returns a character vector that enumerates all fields in the table in the correct order. Works also for temprary tables created by dplyr::copy_to() in Postgres. con %&gt;% dbListFields(&quot;mtcars&quot;) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; 2.2.5 dbExistsTable() Returns a lo’gical scalar, TRUE if the table or view specified by the name argument exists, FALSE otherwise. Works also for temprary tables created by dplyr::copy_to() in Postgres. con %&gt;% dbExistsTable(&quot;mtcars&quot;) ## [1] TRUE con %&gt;% dbExistsTable(&quot;hoge&quot;) ## [1] FALSE 2.2.6 dbRemoveTable() Removes a remote table from the database. Returns TRUE invisibly. Raises an error if the intended table does not exist (see fail_if_missing option below). Cannot remove a view in postges. (Neither DBI nor RPostgres has a method for dropping a view. It must be crafted by the user.) Additional options, which must be called as named ones, include temoprary = FALSE: a logical specifying whether to consider only temprary tables. NOT available with postgres. fail_if_missing = TRUE: a logical specifying whether to raise an error for the call to remove an absent table. if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; con %&gt;% dbRemoveTable(&quot;mtcars&quot;) # remove here con %&gt;% dbListTables() # removed table no longer exists ## character(0) In Postgres, temporary = TRUE causes an error regardless of the existanece of the table. if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbRemoveTable(&quot;mtcars&quot;, temporary = TRUE) # error ## Error: Failed to fetch row: ERROR: schema &quot;pg_temp&quot; does not exist In this case, the asked removal will not be executed. con %&gt;% dbListTables() # the table is still alive ## [1] &quot;mtcars&quot; The following examples illustate the behaviour of the option fail_if_missing =. # fail_if_missing = FALSE makes an otherwise invalid call valid con %&gt;% dbRemoveTable(&quot;absent_table&quot;, fail_if_missing = FALSE) ## NOTICE: table &quot;absent_table&quot; does not exist, skipping # fail_if_missing = TRUE, the default, raises an error for deleting an absent table con %&gt;% dbRemoveTable(&quot;absent_table&quot;) ## Error: Failed to fetch row: ERROR: table &quot;absent_table&quot; does not exist 2.2.7 dbReadTable() Copy data frames from database tables. Returns a data frame that contains the complete data from the remote table. if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbReadTable(&quot;mtcars&quot;) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 2.2.8 dbAppendTable() Inserts rows into a table, assuming that the table has been created beforehand. Returns a scalar numeric equal to the number of rows inserted. The row.names argument must be NULL, the default value. The row names of input data are ignored. In Postgres, DBI::dbAppendTable() is overrideen by RPostgres::dbAppendTable() because RPostgres uses placeholders of the form $1, $2 etc. instead of ?. # create demo table con %&gt;% dbWriteTable(&quot;mtcars2&quot;, mtcars %&gt;% head(2), overwrite = TRUE) # insert 10 rows from tail con %&gt;% DBI::dbAppendTable(name = &quot;mtcars2&quot;, value = mtcars %&gt;% tail(10)) ## [1] 10 # show resulting table con %&gt;% dbReadTable(&quot;mtcars2&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 4 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 5 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 6 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 7 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 8 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 9 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 10 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 11 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## 12 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Appending rows into an absent table raises an error. con %&gt;% dbAppendTable(&quot;iris&quot;, iris %&gt;% head()) ## Error: Failed to initialise COPY: ERROR: relation &quot;iris&quot; does not exist "]]
